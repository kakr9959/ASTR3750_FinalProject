{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np \n",
    "import pylab\n",
    "%matplotlib inline\n",
    "\n",
    "\n",
    "# FUNCTION FOR ESTIMATING NUMBER OF CRATERS FOR SATURATION\n",
    "def estimate(D,S):\n",
    "    \"\"\"\n",
    "    This function gives the number of craters of diameter, D, to fill \n",
    "    a square area of sidelength, S, in a grid with no overlap.\n",
    "    -----------------------------------------------------------------\n",
    "    Arguments:\n",
    "    \n",
    "    D = Diameter of Crater\n",
    "    S = Side length of square area \n",
    "    \n",
    "    *NOTE* \n",
    "    units of D and S must be the same \n",
    "    -----------------------------------------------------------------\n",
    "    Returns:\n",
    "    \n",
    "    The number of craters, expressed as a float, it would take to fill\n",
    "    the square area in a grid with no overlap.\n",
    "    ------------------------------------------------------------------\n",
    "    \"\"\"\n",
    "    \n",
    "    N = (S/D)**2  # S/D gives how many on one side\n",
    "                  # Squaring that gives total  craters in area \n",
    "    \n",
    "    return N \n",
    "\n",
    "\n",
    "\n",
    "# TESTING ESTIMATE FUNCTION \n",
    "guess = estimate(20,500)\n",
    "\n",
    "print(f'''An estimate for how many craters until saturation is \n",
    "{int(guess)} craters.''')\n",
    "\n",
    "\n",
    "\n",
    "# FUNCTION FOR TIME TO REACH A CERTAIN NUMBER OF CRATERS \n",
    "def time(rate,num):\n",
    "    '''\n",
    "    This functions gives how long it takes for the surface to reach \n",
    "    the inputed number of impacts. \n",
    "    -------------------------------------------------------------------\n",
    "    Arguments:\n",
    "    \n",
    "    num = Number of Craters\n",
    "    rate = rate at which craters occur in the form of #/time\n",
    "    \n",
    "    *NOTE*\n",
    "    units of time in rate determine the units of time returned\n",
    "    ------------------------------------------------------------------\n",
    "    Returns:\n",
    "    \n",
    "    The time,expressed as a float it takes for the inputed number of \n",
    "    craters to occur at the inputed rate. \n",
    "    ------------------------------------------------------------------\n",
    "    '''\n",
    "    \n",
    "    t = num/rate\n",
    "    \n",
    "    return t\n",
    "\n",
    "\n",
    "# TESTING TIME FUNCTION \n",
    "t = time(1/1000,guess)\n",
    "\n",
    "print(f'To reach {int(guess)} craters it would take {int(t)} years.')\n",
    "\n",
    "\n",
    "\n",
    "# FUNTION FOR NUMBER OF CRATERS AT CERTAIN TIME \n",
    "def number(rate,t):\n",
    "    \"\"\"\n",
    "    This functions gives the number of craters on the suface at a \n",
    "    certain time. \n",
    "    ---------------------------------------------------------------------\n",
    "    Arguments:\n",
    "    \n",
    "    rate = rate at which craters occur in the form of #/time\n",
    "    t = time \n",
    "    \n",
    "    *NOTE*\n",
    "    units of time in rate and t must be the same \n",
    "    ---------------------------------------------------------------------\n",
    "    Returns:\n",
    "    \n",
    "    The number of craters, expressed as a float, on the surface \n",
    "    at the inputed time.\n",
    "    ---------------------------------------------------------------------\n",
    "    \"\"\"\n",
    "    \n",
    "    N = rate*t  # just rearranging the relation from time function\n",
    "    \n",
    "    return N\n",
    "\n",
    "\n",
    "\n",
    "# A FUNCTION FOR PLOTTING IMPACTS IN A GRID \n",
    "def guess_plot(D,S,rate,frac):\n",
    "    \"\"\"\n",
    "    This function will plot circles of chosen diameter in a grid \n",
    "    pattern over a square are of the surface at a chosen fraction \n",
    "    of time to saturation.\n",
    "    ---------------------------------------------------------------------\n",
    "    Arguments:\n",
    "    \n",
    "    D = diameter of crater\n",
    "    S = side length of square area\n",
    "    rate = rate at which craters occur in the form of #/time in years\n",
    "    frac = fraction of surface covered \n",
    "    \n",
    "    *NOTE*\n",
    "    units of D and S must be the same \n",
    "    ---------------------------------------------------------------------\n",
    "    Returns: \n",
    "    \n",
    "    A plot of the surface cratering at chosen fraction of time \n",
    "    to saturation\n",
    "    ---------------------------------------------------------------------\n",
    "    \n",
    "    \"\"\"\n",
    "    \n",
    "    N = estimate(D,S)\n",
    "    t = time(rate,N)    # Getting the total time for inputed arguments\n",
    "    \n",
    "    t_spec = t*frac      # Gives time at chosen fraction to saturation\n",
    "    n_spec = number(rate,t_spec)   # Gives # of craters at that time\n",
    "    \n",
    "    \n",
    "   # getting x and y grid coordinates  \n",
    "    x = np.arange(int(D/2),int(S+(D/2)),D/frac) \n",
    "    y = np.arange(int(D/2),int(S+(D/2)),D/frac) \n",
    "    \n",
    "    \n",
    "    fig, ax = plt.subplots(figsize=(7,7))\n",
    "    ax.set_facecolor('darkgrey')\n",
    "    plt.axis('scaled')\n",
    "    plt.xlim(0,S)        \n",
    "    plt.ylim(0,S)\n",
    "    \n",
    "    for j in range(int((S/D)*frac)):    #creating the circles\n",
    "        y_coord = y[j]              \n",
    "        \n",
    "        for i in range(len(x)):\n",
    "            circles = plt.Circle((x[i],y_coord),radius=int(D/2),\n",
    "                                 fc = 'dimgrey', ec = 'black')\n",
    "            ax.add_artist(circles)\n",
    "            \n",
    "        plt.title(f'Surface at {t_spec:.0f} years ({n_spec:.0f} craters)')\n",
    "        \n",
    "        \n",
    "    \n",
    "    \n",
    "    plt.show();   \n",
    "\n",
    "    \n",
    "# TESTING GUESS PLOT FUNCTION \n",
    "d = 20\n",
    "s = 500\n",
    "rate = 1/1000\n",
    "guess_plot(d,s,rate,1)\n",
    "\n",
    "\n",
    "# PLOTTING CRATERS VERSUS TIME \n",
    "\n",
    "t_plot = np.arange(0,1e6) # a plot over one million years for x values\n",
    "\n",
    "n = number(rate,t_plot)   # getting the number of craters for y values\n",
    "\n",
    "plt.plot(t_plot,n,color='black') # plotting craters v time \n",
    "\n",
    "plt.axvline(x=t,color='red',linestyle='--') # adding saturation time \n",
    "plt.text(t+4,300,'Saturation',rotation=-90)\n",
    "\n",
    "plt.xlabel('Time Elapsed (years)')\n",
    "plt.ylabel('Number of 20 km Craters')\n",
    "plt.title('Number of Craters vs Time')\n",
    "plt.show();\n",
    "\n",
    "print(f'''Saturation happens at {int(t)} years when {int(guess)} \n",
    "craters are on the surface.''')\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "# A FUNCTION FOR PLOT OF RANDOM IMPACTS \n",
    "def random_plot(D,S,rate,frac,time):\n",
    "    \"\"\"\n",
    "    This function gives a plot of impact craters at a chosen time on a\n",
    "    square surface in random positions. \n",
    "    ------------------------------------------------------------------\n",
    "    Arguments: \n",
    "    \n",
    "    D = diameter of craters \n",
    "    S = side length of square area\n",
    "    rate = rate at which craters occur in the form of #/time in years\n",
    "    frac = fraction of total time\n",
    "    time = total time of impacting \n",
    "    ------------------------------------------------------------------\n",
    "    Returns:\n",
    "    \n",
    "    A plot of the surface cratering at chosen time or fraction of time\n",
    "    ------------------------------------------------------------------\n",
    "    \n",
    "    \"\"\"\n",
    "    \n",
    "    N = number(rate,time)\n",
    "    \n",
    "    t_spec = time*frac      # Gives time at chosen fraction to saturation\n",
    "    n_spec = number(rate,t_spec)   # Gives # of craters at that time\n",
    "    \n",
    "    xpos = 500*np.random.rand(int(N)) # random x positions\n",
    "    ypos = 500*np.random.rand(int(N)) # random y positions\n",
    "\n",
    "    \n",
    "\n",
    "    fig, ax = plt.subplots(figsize=(7,7))\n",
    "    ax.set_facecolor('darkgrey')\n",
    "    plt.axis('scaled')\n",
    "    plt.xlim(0,S)\n",
    "    plt.ylim(0,S)\n",
    "    \n",
    "    for i in range(int(N*frac)):     #creating the circles \n",
    "        circles = plt.Circle((xpos[i],ypos[i]),radius=int(D/2),\n",
    "                                 fc = 'dimgrey', ec = 'black')\n",
    "        ax.add_artist(circles)\n",
    "        plt.title(f'Surface at {t_spec:.0f} years ({n_spec:.0f} craters)')\n",
    "    \n",
    "        \n",
    "    \n",
    "    \n",
    "plt.show();\n",
    "\n",
    "# TESTING RANDOM PLOT FINCTION\n",
    "\n",
    "random_plot(20,500,1/1000,1,t)\n",
    "\n",
    "\n",
    "# MAKING AN ANIMATION OF RANDOM IMPACTS \n",
    "\n",
    "from IPython.display import Video\n",
    "import matplotlib.animation as ani\n",
    "\n",
    "# getting the total # of craters\n",
    "N_longer = number(1/1000,int(t+5e6)) \n",
    "\n",
    "# getting N_longer number of x and y positions\n",
    "xpos_longer = 500*np.random.random(int(N_longer))  \n",
    "ypos_longer = 500*np.random.random(int(N_longer)) \n",
    "\n",
    "\n",
    "writer = ani.FFMpegWriter(fps=25)\n",
    "\n",
    "\n",
    "fig, ax = plt.subplots(figsize=(7,7))\n",
    "ax.set_facecolor('darkgrey')\n",
    "plt.axis('scaled')\n",
    "plt.xlim(0,500)      \n",
    "plt.ylim(0,500)\n",
    "\n",
    "\n",
    "with writer.saving(fig,'impact_sim.mp4',100):\n",
    "    for i in range(0,int(t+5e6),1000):  # looping through the longer time\n",
    "        \n",
    "        n = int((1/1000)*i)  #getting # of craters at each time\n",
    "        \n",
    "        #making the circles at random positions\n",
    "        circles = plt.Circle((xpos_longer[n],ypos_longer[n]),\n",
    "                             radius=10,fc = 'dimgrey', ec = 'black')\n",
    "        ax.add_artist(circles)\n",
    "        plt.title(f'Surface at {i+1000} years ({n+1} craters)')\n",
    "    \n",
    "        \n",
    "        writer.grab_frame()\n",
    "\n",
    "\n",
    "        \n",
    "        \n",
    "        \n",
    "# CREATING THE PLOT FOR CRATERS VS TIME \n",
    "\n",
    "t_8 = np.arange(longer_t) #getting t values \n",
    "n = number(rate,t_8)   # getting the number of craters for y values\n",
    "\n",
    "\n",
    "\n",
    "plt.plot(t_8,n,color='black')  # plotting craters v time\n",
    "\n",
    "# adding saturation time \n",
    "plt.axvline(x=2.5e6,color='red',linestyle='--') \n",
    "plt.text(2.5e6+4,2500,'Saturation for random',rotation=-90)\n",
    "# adding saturation time \n",
    "plt.axvline(x=t,color='red',linestyle='--') \n",
    "plt.text(t+4,3000,'Saturation for grid',rotation=-90)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "plt.xlabel('Time Elapsed (years)')\n",
    "plt.ylabel('Number of 20 km Craters')\n",
    "plt.title('Number of Craters vs Time')\n",
    "plt.show();\n",
    "\n",
    "\n",
    "print(f'''Saturation for random impacts happens at {2.5e6:.0f} years \n",
    "when {2500} craters are on the surface.''')\n",
    "\n",
    "print(f'''Saturation for grid impacts happens at {int(t)} years \n",
    "when {int(guess)} craters are on the surface.''')"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
